      TI301 â€“ Algorithmique et Structures de donnÃ©es 2

               Projet Informatique et MathÃ©matiques
         Ce projet est rÃ©digÃ© en commun avec le dÃ©partement de
                              mathÃ©matiques

             Etude de Graphes de Markov â€“ PARTIE 2

Nous allons maintenant nous intÃ©resser aux propriÃ©tÃ©s des graphes de Markov.

Pour obtenir lâ€™ensemble de ces propriÃ©tÃ©s, deux Ã©tapes sont fondamentales

Ã‰tape 1 â€“ Regroupement de sommets en classes
Dans ces graphes, nous allons rassembler certains sommets entre eux, selon le critÃ¨re suivant :

  Des sommets doivent Ãªtre regroupÃ©s dans une classe sâ€™ils communiquent tous entre eux,
  câ€™est Ã  dire quâ€™Ã  partir dâ€™un de ces sommets, on peut accÃ©der Ã  tous les sommets de
  cette classe (lui-mÃªme y compris).


Ces regroupements de sommets sont nommÃ©s composantes fortement connexes ou
classes.

Quelques exemples


                                                      0.5 0.5 0   0
                                                       0 0.5 0.5 0
   1) Graphe avec 4 sommets, sa matrice est ğ‘€ =
                                                       0   0 0.5 0.5
                                                      0.5 0   0 0.5




       Ici, tous les sommets communiquent entre eux : partant dâ€™un sommet, on peut accÃ©der
       Ã  tous les autres, et y revenir. On doit regrouper les 4 sommes dans une classe que lâ€™on
       nommera {1,2,3,4}
    2) Graphe avec 10 sommets, utilisÃ© pour valider lâ€™Ã©tape 3 de la partie 1




    ï‚·   Le sommet 2 ne communique quâ€™avec lui-mÃªme : il forme une classe Ã  lui seul
    ï‚·   Le sommet 4 ne communique quâ€™avec lui-mÃªme : il forme une classe Ã  lui seul
    ï‚·   Le sommet 10 forme une classe Ã  lui seul Ã©galement : on peut partir de 10 vers dâ€™autres
        sommets, mais on ne peut pas y revenir.
    ï‚·   Le sommet 9 est dans le mÃªme cas : on peut en partir mais pas y revenir
    ï‚·   Les sommets 1, 5 et 7 forment une classe : partant de 1, 5 ou 7, on peut toujours revenir
        Ã  1,5 ou 7
    ï‚·   Les sommets 3, 6 et 8 forment une classe : partant de 3, 6 ou 8, on peut toujours revenir
        Ã  3, 6 ou 8.

Pour ce graphe, lâ€™ensemble des classes est donc : {1,5,7}, {2}, {3,6,8}, {4}, {9} et {10}.

PropriÃ©tÃ©s des classes
   ïƒ¼ Tout sommet du graphe appartient Ã  une et une seule classe ;
   ïƒ¼ Tout sommet du graphe doit appartenir Ã  une classe ;
   ïƒ¼ Toute classe comporte au moins 1 sommet ;
   ïƒ¼ Un graphe comprend au moins 1 classe ;
   ïƒ¼ Lâ€™ensemble des classes dâ€™un graphe sâ€™appelle une partition.



DÃ©terminer ces classes
Pour dÃ©terminer ces classes, de nombreux algorithmes existent, chacun avec sa di icultÃ© de
conception (est-il facile Ã  concevoir, Ã  comprendre ?) et sa complexitÃ© (est-il e icace ?). Les
algorithmes les plus simples Ã  comprendre et concevoir ont en gÃ©nÃ©ral une mauvaise
complexitÃ©, en ğ‘‚(N ) au minimum (N Ã©tant le nombre de sommets).
Nous allons utiliser un algorithme trÃ¨s e icace pour rÃ©aliser la partition du graphe en classes :
lâ€™algorithme de Tarjan (voir https://fr.wikipedia.org/wiki/Algorithme_de_Tarjan). Câ€™est la version
de cet algorithme que vous devrez implÃ©menter.

Cet algorithme Ã©tant assez complexe (notamment, sa prÃ©sentation sur la page wikipedia
nÃ©cessite une fonction dans une fonction, ce qui nâ€™est pas rÃ©alisable facilement avec ce que
nous savons faire pour le moment), il sera dÃ©composÃ© en Ã©tapes.

Etape 1 pour lâ€™algorithme de Tarjan â€“ structures de donnÃ©es


1.1)  Cet algorithme utilise des informations associÃ©es Ã  chaque sommet :
    ïƒ¼ Un identiï¬ant (entier) : câ€™est le numÃ©ro du sommet dans le graphe, tel que vu en Partie
      1
    ïƒ¼ Un numÃ©ro (entier) : pour e ectuer une numÃ©rotation temporaire pour dÃ©terminer les
      classes â€“ ce numÃ©ro nâ€™est pas le numÃ©ro du sommet dans le graphe !
    ïƒ¼ Un numÃ©ro accessible (entier): pour regrouper les sommets qui communiquent
      ensemble
    ïƒ¼ Un indicateur boolÃ©en (un entier valant 0 ou 1) indiquant si le sommet est dans la pile
      de traitement ou pas (lâ€™algorithme utilise une pile).



   ïƒ˜ Il vous faut donc crÃ©er une structure de donnÃ©es correspondante. Pour continuer
     lâ€™exemple, supposons que ce type sâ€™appelle t_tarjan_vertex (ce nâ€™est quâ€™un
     exemple, vous pouvez choisir le nom que vous souhaitez).

1.2)   Cet algorithme a besoin de connaÃ®tre lâ€™Ã©tat de tous les sommets quand il sâ€™exÃ©cute.

   ïƒ˜ Il vous faut donc crÃ©er un tableau stockant tous les t_tarjan_vertex pour un
     graphe.


1.3)   Cet algorithme utilise des classes, pour y stocker les sommets au fur et Ã  mesure. Une
       classe stocke des â€˜sommetsâ€™ t_tarjan_vertex, et a un nom : Â« C1 Â», Â« C2 Â»â€¦.

   ïƒ˜ Il vous faut donc crÃ©er une structure de donnÃ©es correspondante, qui stocke un nom
     (le nom de la classe) et â€˜un certain nombre deâ€˜ sommets t_tarjan_vertex. Pour
     continuer lâ€™exemple, supposons que ce type sâ€™appelle t_classe.

       A vous de choisir comment faire ce stockage, sachant quâ€™on ne sait pas Ã  lâ€™avance
       combien une classe contiendra de sommets.
1.4)   Cet algorithme fournit la partition du graphe en classes. Une partition est un ensemble de
       classes.

   ïƒ˜ Il vous faut donc crÃ©er une structure de donnÃ©es correspondante, qui stocke â€˜un
     certain nombre de classes t_classe. (Ã  vous de choisir comment faire ce stockage)

       A vous de choisir comment faire ce stockage, sachant quâ€™on ne sait pas Ã  lâ€™avance
       combien une partition contiendra de classes.


Etape 2 pour lâ€™algorithme de Tarjan â€“ Ã©lÃ©ments utilitaires
Il est trÃ¨s fortement conseillÃ© dâ€™implÃ©menter les Ã©lÃ©ments suivants :

2.1) Une fonction Ã  qui on fournit un graphe (une liste dâ€™adjacence) et qui retourne un tableau de
t_tarjan_vertex, (un pour chaque sommet prÃ©sent dans la liste dâ€™adjacence), initialisÃ©
avec :

   ïƒ¼ identiï¬ant (entier) : numÃ©ro du sommet dans le graphe (liste dâ€™adjacence)
   ïƒ¼ numÃ©ro (entier) : -1
   ïƒ¼ numÃ©ro accessible (entier): -1
   ïƒ¼ Un indicateur boolÃ©en (un entier valant 0 ou 1) : 0



2.2) Une pile dans laquelle on stockera des int ou des t_tarjan_vertex
Etape 3 pour lâ€™algorithme de Tarjan â€“ dÃ©coupage en fonctions
3.1) Ã‰crire une fonction qui rÃ©alise la sous-fonction nommÃ©e â€˜parcoursâ€™ de la page wikipedia.
Attention, cette fonction aura besoin de 5 ou 6 paramÃ¨tres.

3.2) Ã‰crire une fonction â€˜tarjanâ€™ qui initialise une partition vide, les t_tarjan_vertex, une
pile vide, et initie les parcours.

Validation de lâ€™Ã©tape 1
Voici le type de sortie attendue pour le rÃ©sultat de lâ€™algorithme de Tarjan.

Avec le graphe :




La sortie du programme devrait Ãªtre : (seules les valeurs sont importantes, pas les formats
dâ€™a ichage)
Composante      C1:   {1,7,5}
Composante      C2:   {2}
Composante      C3:   {3,8,6}
Composante      C4:   {4}
Composante      C5:   {9}
Composante      C6:   {10}

Lâ€™ordre dans lequel les composantes sont a ichÃ©es nâ€™a pas dâ€™importance
Ã‰tape 2 â€“ Diagramme de Hasse
On cherche maintenant Ã  obtenir le diagramme de Hasse associÃ© aux classes obtenues Ã  lâ€™Ã©tape
1.

Ce diagramme indique les communications entre classes. En e et, certains sommets dâ€™une
classe peuvent mener Ã  des sommets dâ€™autres classes (mais il nâ€™y a pas de â€˜retourâ€™ possible).

Ce diagramme de Hasse nous permettra dâ€™obtenir toutes les propriÃ©tÃ©s des sommets, des
classes, et du graphe de Markov.

Illustration, toujours avec le mÃªme graphe pris en exemple.




Les classes sont :
Composante     C1:   {1,7,5}
Composante     C2:   {2}
Composante     C3:   {3,8,6}
Composante     C4:   {4}
Composante     C5:   {9}
Composante     C6:   {10}


Du sommet 10, on peut aller vers sommet 4 : on a donc un lien de C6 vers C4, que lâ€™on
reprÃ©sentera par C6->C4

Du sommet 10, on peut aller vers le sommet 7 : on a donc un lien de C6 vers C1 : C6->C1

Du sommet 10, on peut aller vers le sommet 5 : on a donc un lien de C6 vers C1 (dÃ©jÃ  identiï¬Ã©)

Du sommet 1, on peut aller vers les sommets 5 et 7, qui sont dans la mÃªme classe C1 : pas de
lien entre classes
En suivant le mÃªme principe pour tous les sommets, on obtient ï¬nalement (visuel ï¬nal avec
Mermaid)




[EN OPTION] DerniÃ¨re dÃ©ï¬nition
Dans ce diagramme, on ne devrait pas trouver de redondance.

Par exemple, pour le graphe suivant :




Les classes sont {1}, {2,3}, {4}, {5,6}

Les liens entre classes produisent le diagramme suivant :


                                                            Il y a une redondance, car

                                                            le lien de {1} vers {5,6}

                                                            est redondant avec

                                                            le lien de {1} vers {2,3} + le lien de
                                                            {2,3} vers {5,6}.
Le diagramme de Hasse est un diagramme sans redondance. Pour le mÃªme graphe, on obtient :




Comment recenser les liens
Pour obtenir un algorithme e icace, nous allons utiliser procÃ©der ainsi :

   ïƒ¼ CrÃ©ez une structure â€˜lienâ€™ qui stockera 2 entiers : un entier pour la classe de Â« dÃ©part Â»,
     un entier pour la classe dâ€™ Â« arrivÃ©e Â».
   ïƒ¼ CrÃ©ez une structure pour stocker plusieurs â€˜liensâ€™.
   ïƒ¼ CrÃ©er un tableau qui indique, pour chaque sommet du graphe, la classe Ã  laquelle il
     appartient.

Attention, pour le moment, chaque classe â€˜connaÃ®tâ€™ les sommets qui la composent, mais chaque
sommet ne â€˜connaÃ®tâ€™ pas la classe Ã  laquelle il appartient.

Voici lâ€™algorithme Ã  implÃ©menter
Pour chaque sommet i du graphe
        Ci = classe Ã  laquelle appartient i // avec le tableau
        Pour tous les sommets j dans la liste dâ€™adjacence du sommet i
                Cj = classe Ã  laquelle appartient j // avec le tableau
                Si Ci est diffÃ©rent de Cj // arÃªte entre classes
                      Si le lien (Ci,Cj) nâ€™existe pas
                           Ajouter le lien (Ci,Cj) dans la structure qui
stocke les liens


[EN OPTION] Comment retirer les redondances
La fonction qui rÃ©alise cette opÃ©ration est dÃ©jÃ  programmÃ©e : elle se trouve dans le module
hasse.h / hasse.c.

son prototype est : void removeTransitiveLinks(t_link_array *p_link_array);



Il vous faudra probablement lâ€™adapter Ã  vos propres structures de donnÃ©es.
Validation de lâ€™Ã©tape 2
Produire un diagramme de Hasse (avec ou sans redondances) au format Mermaid, par exemple :




Vous aurez besoin, pour construire ces diagrammes, de la partition du graphe (ensemble des
classes) et de tous les liens entre classes que vous aurez trouvÃ©s.

Ã‰tape 3 : caractÃ©ristiques du graphe
Une fois les classes et les liens obtenus, ces caractÃ©ristiques sâ€™obtiennent de maniÃ¨re quasi
immÃ©diate :

   ïƒ¼ Une classe est dite â€˜transitoireâ€™ si on peut â€˜sortirâ€™ de cette classe : il existe une â€˜ï¬‚Ã¨che
     sortanteâ€™ de cette classe. Tous les Ã©tats de cette classe sont dits â€˜transitoiresâ€™.
   ïƒ¼ Une classe est dite â€˜persistanteâ€™ si on ne peut pas â€˜sortirâ€™ de cette classe : il nâ€™y a pas de
     ï¬‚Ã¨che â€˜sortanteâ€™ de cette classe. Tous les Ã©tats de cette classe sont dits â€˜persistantsâ€™
   ïƒ¼ Un Ã©tat est dit â€˜absorbantâ€™ sâ€™il est dans une classe persistante, et quâ€™il est le seul Ã©tat de
     cette classe.
   ïƒ¼ Un graphe de Markov est dit â€˜irrÃ©ductibleâ€™ sâ€™il nâ€™est composÃ© que dâ€™une seule classe.

Sur le schÃ©ma de droite :

   ïƒ¼   La classe {1} est transitoire â€“ lâ€™Ã©tat 1 est transitoire ;
   ïƒ¼   La classe {2,3} est transitoire â€“ les Ã©tats 2 et 3 sont transitoires ;
   ïƒ¼   La classe {4} est persistante â€“ lâ€™Ã©tat 4 est persistant â€“ lâ€™Ã©tat 4 est absorbant ;
   ïƒ¼   La classe {5,6} est persistante â€“ les Ã©tats 5 et 6 sont persistants ;
   ïƒ¼   Le graphe de Markov nâ€™est pas irrÃ©ductible.

Validation de lâ€™Ã©tape 3
Votre programme a iche toutes les caractÃ©ristiques du graphe :

   ïƒ¼ Si les classes sont transitoires ou persistantes ;
   ïƒ¼ Sâ€™il y a des Ã©tats absorbants ;
   ïƒ¼ Si le graphe est irrÃ©ductible ou non.
